{% comment %}
  Bundle Components Display Section - Dynamic Variant Mapping
  Retrieves variant IDs dynamically from metafields and API calls
  No hardcoded variant IDs - fully dynamic and error-resistant
{% endcomment %}

{% if product.metafields.bundle_app.is_bundle %}
  <style>
    /* Bundle components styling */
    .bundle-components-wrapper {
      margin: 20px 0;
      position: relative;
      z-index: 10;
    }
    
    .bundle-product-container {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      margin-bottom: 15px;
      padding: 15px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #fafafa;
    }
    
    .bundle-product-image {
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
      border: 1px solid #ddd;
    }
    
    .bundle-product-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .bundle-product-info {
      flex-grow: 1;
    }
    
    .bundle-product-title {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .bundle-product-price {
      font-size: 14px;
      color: #666;
      font-weight: 500;
    }
    
    .bundle-loading {
      text-align: center;
      padding: 20px;
      color: #666;
      font-style: italic;
    }
    
    .bundle-error {
      text-align: center;
      padding: 20px;
      color: #d32f2f;
      background: #ffebee;
      border-radius: 8px;
      margin: 10px 0;
    }
    
    /* Hide original variant selector when bundle is active */
    .bundle-active .product-form__input {
      display: none !important;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .bundle-product-container {
        flex-direction: column;
        gap: 15px;
      }
      
      .bundle-product-image {
        width: 60px;
        height: 60px;
        align-self: center;
      }
    }
  </style>
  
  <!-- Dynamic HTML container - populated by JavaScript -->
  <div class="bundle-components-wrapper" id="bundle-components-display" data-product-id="{{ product.id }}">
    <div class="bundle-loading">Loading bundle components...</div>
  </div>
  
  <script>
    (function() {
      'use strict';
      
      const PRODUCT_ID = {{ product.id }};
      const SHOP_DOMAIN = '{{ shop.permanent_domain }}';
      
      console.log('Dynamic Bundle System: Loading for product', PRODUCT_ID);
      
      // Global state
      let bundleComponentData = null;
      let variantSyncMapping = null;
      let currentSelectedVariant = 'S'; // Default
      
      // Initialize dynamic bundle system
      function initDynamicBundleSystem() {
        // Try to load from Liquid metafields first
        loadFromLiquidMetafields()
          .then(success => {
            if (success) {
              console.log('Dynamic Bundle: Loaded from Liquid metafields');
              renderBundleComponents();
              setupVariantMonitoring();
              setupCartIntegration();
            } else {
              console.log('Dynamic Bundle: Falling back to API calls');
              loadFromAPIFallback();
            }
          })
          .catch(error => {
            console.error('Dynamic Bundle: Error loading from metafields', error);
            loadFromAPIFallback();
          });
      }
      
      function loadFromLiquidMetafields() {
        return new Promise((resolve) => {
          try {
            // Try to parse component products from Liquid metafields
            {% if product.metafields.bundle_app.component_products %}
              const componentProductsRaw = {{ product.metafields.bundle_app.component_products | json }};
              bundleComponentData = typeof componentProductsRaw === 'string' 
                ? JSON.parse(componentProductsRaw) 
                : componentProductsRaw;
            {% endif %}
            
            {% if product.metafields.bundle_app.variant_sync_mapping %}
              const variantSyncRaw = {{ product.metafields.bundle_app.variant_sync_mapping | json }};
              variantSyncMapping = typeof variantSyncRaw === 'string' 
                ? JSON.parse(variantSyncRaw) 
                : variantSyncRaw;
            {% endif %}
            
            if (bundleComponentData && variantSyncMapping) {
              console.log('Dynamic Bundle: Successfully loaded metafield data');
              console.log('Components:', bundleComponentData.length);
              console.log('Variant mapping available:', !!variantSyncMapping.componentVariantsBySize);
              resolve(true);
            } else {
              console.log('Dynamic Bundle: Metafield data incomplete');
              resolve(false);
            }
          } catch (error) {
            console.error('Dynamic Bundle: Error parsing metafields', error);
            resolve(false);
          }
        });
      }
      
      function loadFromAPIFallback() {
        console.log('Dynamic Bundle: Loading component data via API...');
        
        // Show loading state
        updateBundleDisplay('<div class="bundle-loading">Loading component data from API...</div>');
        
        // Fetch product data including metafields via Shopify API
        fetch(`/products/${PRODUCT_ID}.js`)
          .then(response => response.json())
          .then(productData => {
            console.log('Dynamic Bundle: Got product data, fetching component details...');
            return fetchComponentProductDetails(productData);
          })
          .then(componentData => {
            if (componentData && componentData.length > 0) {
              bundleComponentData = componentData;
              buildVariantSyncMapping();
              renderBundleComponents();
              setupVariantMonitoring();
              setupCartIntegration();
            } else {
              showError('No component products found for this bundle.');
            }
          })
          .catch(error => {
            console.error('Dynamic Bundle: API fallback failed', error);
            showError('Failed to load bundle components. Please refresh the page.');
          });
      }
      
      function fetchComponentProductDetails(mainProduct) {
        // Extract component product handles from tags or other indicators
        const bundleTags = mainProduct.tags || [];
        const componentHandles = [];
        
        // Look for component product handles in various ways
        bundleTags.forEach(tag => {
          if (tag.includes('component:')) {
            componentHandles.push(tag.replace('component:', ''));
          }
        });
        
        // If no handles found, try to construct them from the main product handle
        if (componentHandles.length === 0) {
          const baseHandle = mainProduct.handle;
          // Common patterns for component handles
          const possibleHandles = [
            `${baseHandle}-top`,
            `${baseHandle}-bottom`,
            `${baseHandle}-jacket`,
            `${baseHandle.replace('-set', '')}-top`,
            `${baseHandle.replace('-set', '')}-bottom`,
            `${baseHandle.replace('-set', '')}-jacket`
          ];
          componentHandles.push(...possibleHandles);
        }
        
        console.log('Dynamic Bundle: Searching for component handles:', componentHandles);
        
        // Fetch each component product
        const fetchPromises = componentHandles.map(handle => 
          fetch(`/products/${handle}.js`)
            .then(response => {
              if (response.ok) {
                return response.json();
              }
              throw new Error(`Component ${handle} not found`);
            })
            .catch(error => {
              console.log(`Dynamic Bundle: Component ${handle} not available:`, error.message);
              return null;
            })
        );
        
        return Promise.all(fetchPromises)
          .then(results => {
            const validComponents = results.filter(component => component !== null);
            console.log(`Dynamic Bundle: Found ${validComponents.length} valid components`);
            
            // Transform to our expected format
            return validComponents.map((component, index) => {
              const componentType = detectComponentType(component.title, component.handle);
              
              return {
                id: component.id,
                handle: component.handle,
                title: component.title,
                price: component.price / 100, // Convert from cents
                image: component.featured_image,
                componentType: componentType,
                variants: component.variants.map(v => ({
                  id: v.id,
                  title: v.title,
                  price: v.price / 100,
                  option1: v.option1,
                  option2: v.option2,
                  option3: v.option3,
                  available: v.available,
                  inventory_quantity: v.inventory_quantity
                })),
                variantMapping: component.variants.reduce((mapping, variant) => {
                  const size = variant.option1 || variant.title;
                  if (size) {
                    mapping[size.toUpperCase()] = variant.id;
                  }
                  return mapping;
                }, {})
              };
            });
          });
      }
      
      function detectComponentType(title, handle) {
        const titleLower = title.toLowerCase();
        const handleLower = handle.toLowerCase();
        
        if (titleLower.includes('top') || handleLower.includes('top')) {
          return 'Top';
        } else if (titleLower.includes('bottom') || handleLower.includes('bottom')) {
          return 'Bottom';
        } else if (titleLower.includes('jacket') || handleLower.includes('jacket')) {
          return 'Jacket';
        } else if (titleLower.includes('dupatta') || handleLower.includes('dupatta')) {
          return 'Dupatta';
        } else {
          return 'Component';
        }
      }
      
      function buildVariantSyncMapping() {
        if (!bundleComponentData) return;
        
        variantSyncMapping = {
          componentVariantsBySize: {},
          lastUpdated: new Date().toISOString(),
          bundleProductId: PRODUCT_ID
        };
        
        // Build size-based mapping
        bundleComponentData.forEach(component => {
          component.variants.forEach(variant => {
            const size = variant.option1 || variant.title;
            if (size) {
              const sizeKey = size.toUpperCase();
              if (!variantSyncMapping.componentVariantsBySize[sizeKey]) {
                variantSyncMapping.componentVariantsBySize[sizeKey] = {};
              }
              variantSyncMapping.componentVariantsBySize[sizeKey][component.componentType] = {
                variantId: variant.id,
                productId: component.id,
                title: variant.title,
                price: variant.price,
                available: variant.available
              };
            }
          });
        });
        
        console.log('Dynamic Bundle: Built variant sync mapping', variantSyncMapping);
      }
      
      function renderBundleComponents() {
        if (!bundleComponentData || bundleComponentData.length === 0) {
          showError('No bundle components available.');
          return;
        }
        
        let html = '';
        
        bundleComponentData.forEach((component, index) => {
          const imageUrl = component.image || '/assets/no-image.png';
          const formattedPrice = `Rs. ${parseFloat(component.price).toFixed(2)}`;
          
          html += `
            <div class="bundle-product-container" data-component-id="${component.id}" data-component-index="${index}">
              <div class="bundle-product-image">
                <img src="${imageUrl}" alt="${component.title}" loading="lazy">
              </div>
              <div class="bundle-product-info">
                <div class="bundle-product-title">${component.title}</div>
                <div class="bundle-product-price">${formattedPrice}</div>
              </div>
            </div>
          `;
        });
        
        updateBundleDisplay(html);
        positionBundleComponents();
        
        console.log('Dynamic Bundle: Rendered components successfully');
      }
      
      function updateBundleDisplay(html) {
        const container = document.getElementById('bundle-components-display');
        if (container) {
          container.innerHTML = html;
        }
      }
      
      function showError(message) {
        updateBundleDisplay(`<div class="bundle-error">${message}</div>`);
      }
      
      function positionBundleComponents() {
        const bundleWrapper = document.getElementById('bundle-components-display');
        if (!bundleWrapper) return;
        
        // Try to position above data-section-container
        const possibleTargets = [
          '[data-section-container]',
          '.product__info',
          '.product-form',
          'main[role="main"]',
          '#MainContent',
          '.main-content'
        ];
        
        let targetElement = null;
        for (let selector of possibleTargets) {
          targetElement = document.querySelector(selector);
          if (targetElement) {
            console.log('Dynamic Bundle: Found target element:', selector);
            break;
          }
        }
        
        if (targetElement && bundleWrapper.parentNode !== targetElement.parentNode) {
          bundleWrapper.remove();
          targetElement.parentNode.insertBefore(bundleWrapper, targetElement);
          console.log('Dynamic Bundle: Repositioned components');
        }
        
        // Add bundle-active class to hide original selectors
        const productForm = document.querySelector('.product__info, .product-form');
        if (productForm) {
          productForm.classList.add('bundle-active');
        }
      }
      
      function setupVariantMonitoring() {
        console.log('Dynamic Bundle: Setting up variant monitoring');
        
        // Multiple monitoring approaches for instant response
        setupClickMonitoring();
        setupFormMonitoring();
        setupDOMObserver();
        setupPollingFallback();
      }
      
      function setupClickMonitoring() {
        document.addEventListener('click', function(e) {
          const target = e.target;
          if (target.classList.contains('product-options__value')) {
            const selectedSize = (target.getAttribute('data-value') || target.textContent.trim()).toUpperCase();
            updateSelectedVariant(selectedSize);
          }
        });
      }
      
      function setupFormMonitoring() {
        const formInputs = document.querySelectorAll('input[name="id"], select[name="id"]');
        formInputs.forEach(input => {
          input.addEventListener('change', function() {
            updateVariantFromForm();
          });
        });
      }
      
      function setupDOMObserver() {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const target = mutation.target;
              if (target.classList.contains('active') && target.classList.contains('product-options__value')) {
                const selectedSize = (target.getAttribute('data-value') || target.textContent.trim()).toUpperCase();
                updateSelectedVariant(selectedSize);
              }
            }
          });
        });
        
        const productForm = document.querySelector('.product__info, .product-form');
        if (productForm) {
          observer.observe(productForm, {
            attributes: true,
            childList: true,
            subtree: true,
            attributeFilter: ['class']
          });
        }
      }
      
      function setupPollingFallback() {
        setInterval(function() {
          const activeOption = document.querySelector('.product-options__value.active');
          if (activeOption) {
            const selectedSize = (activeOption.getAttribute('data-value') || activeOption.textContent.trim()).toUpperCase();
            if (currentSelectedVariant !== selectedSize) {
              updateSelectedVariant(selectedSize);
            }
          }
        }, 200);
      }
      
      function updateVariantFromForm() {
        // This would need the main product's variant mapping
        // For now, try to detect from active elements
        const activeOption = document.querySelector('.product-options__value.active');
        if (activeOption) {
          const selectedSize = (activeOption.getAttribute('data-value') || activeOption.textContent.trim()).toUpperCase();
          updateSelectedVariant(selectedSize);
        }
      }
      
      function updateSelectedVariant(size) {
        if (currentSelectedVariant !== size) {
          currentSelectedVariant = size;
          console.log('Dynamic Bundle: Variant updated to', size);
        }
      }
      
      function setupCartIntegration() {
        console.log('Dynamic Bundle: Setting up cart integration');
        
        // Override cart submission
        function handleBundleCartSubmit(e) {
          e.preventDefault();
          e.stopPropagation();
          
          console.log('Dynamic Bundle: Cart submit triggered for size', currentSelectedVariant);
          
          if (!variantSyncMapping || !variantSyncMapping.componentVariantsBySize) {
            console.error('Dynamic Bundle: No variant sync mapping available');
            alert('Bundle configuration error. Please refresh the page and try again.');
            return;
          }
          
          const sizeMapping = variantSyncMapping.componentVariantsBySize[currentSelectedVariant];
          if (!sizeMapping) {
            console.error('Dynamic Bundle: No mapping for size', currentSelectedVariant);
            alert(`Size ${currentSelectedVariant} is not available for this bundle.`);
            return;
          }
          
          // Build cart items from dynamic mapping
          const cartItems = [];
          Object.keys(sizeMapping).forEach(componentType => {
            const componentData = sizeMapping[componentType];
            if (componentData && componentData.available !== false) {
              cartItems.push({
                id: parseInt(componentData.variantId),
                quantity: 1,
                properties: {
                  '_bundle_product': 'true',
                  '_bundle_id': PRODUCT_ID.toString(),
                  '_bundle_component': componentType,
                  '_bundle_size': currentSelectedVariant,
                  '_component_title': componentData.title,
                  '_bundle_sync_enabled': 'true',
                  '_auto_remove_siblings': 'true'
                }
              });
            }
          });
          
          if (cartItems.length === 0) {
            alert('No available items to add to cart for the selected size.');
            return;
          }
          
          console.log('Dynamic Bundle: Adding items to cart', cartItems);
          
          // Disable buttons and show loading
          const submitButtons = document.querySelectorAll('button[name="add"], input[type="submit"][name="add"], .product-form__submit');
          const originalTexts = [];
          submitButtons.forEach((btn, index) => {
            originalTexts[index] = btn.textContent || btn.value;
            btn.disabled = true;
            if (btn.textContent) {
              btn.textContent = 'Adding Bundle...';
            } else {
              btn.value = 'Adding Bundle...';
            }
          });
          
          // Add to cart
          fetch('/cart/add.js', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({ items: cartItems })
          })
          .then(response => {
            if (!response.ok) {
              return response.text().then(text => {
                let errorMessage = 'Failed to add items to cart';
                try {
                  const errorData = JSON.parse(text);
                  if (errorData.message) errorMessage = errorData.message;
                  else if (errorData.description) errorMessage = errorData.description;
                } catch (e) {
                  if (text) errorMessage = text;
                }
                throw new Error(errorMessage);
              });
            }
            return response.json();
          })
          .then(data => {
            console.log('Dynamic Bundle: Successfully added to cart', data);
            
            // Show success
            submitButtons.forEach(btn => {
              if (btn.textContent) {
                btn.textContent = 'Added to Cart!';
              } else {
                btn.value = 'Added to Cart!';
              }
            });
            
            // Trigger cart events
            triggerCartUpdateEvents();
            
            // Restore buttons
            setTimeout(() => {
              submitButtons.forEach((btn, index) => {
                btn.disabled = false;
                if (btn.textContent) {
                  btn.textContent = originalTexts[index];
                } else {
                  btn.value = originalTexts[index];
                }
              });
            }, 2000);
          })
          .catch(error => {
            console.error('Dynamic Bundle: Cart error', error);
            alert(`Failed to add bundle to cart: ${error.message}`);
            
            // Restore buttons
            submitButtons.forEach((btn, index) => {
              btn.disabled = false;
              if (btn.textContent) {
                btn.textContent = originalTexts[index];
              } else {
                btn.value = originalTexts[index];
              }
            });
          });
        }
        
        function triggerCartUpdateEvents() {
          document.dispatchEvent(new CustomEvent('cart:updated'));
          document.dispatchEvent(new CustomEvent('cornerCart:update'));
          document.dispatchEvent(new CustomEvent('cart:change'));
          window.dispatchEvent(new Event('cartChanged'));
          
          if (typeof jQuery !== 'undefined') {
            jQuery(document).trigger('cart.requestComplete');
            jQuery(document).trigger('cartUpdated');
          }
          
          console.log('Dynamic Bundle: Cart update events triggered');
        }
        
        // Override cart mechanisms
        function overrideCartMechanisms() {
          const forms = document.querySelectorAll('form[action*="/cart/add"]');
          forms.forEach(form => {
            const newForm = form.cloneNode(true);
            form.parentNode.replaceChild(newForm, form);
            newForm.addEventListener('submit', handleBundleCartSubmit);
          });
          
          const buttons = document.querySelectorAll('button[name="add"], input[type="submit"][name="add"], .product-form__submit');
          buttons.forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            newButton.addEventListener('click', handleBundleCartSubmit);
          });
          
          document.addEventListener('click', function(e) {
            const target = e.target;
            if (target.matches('button[name="add"], input[type="submit"][name="add"], .product-form__submit') ||
                target.closest('button[name="add"], input[type="submit"][name="add"], .product-form__submit')) {
              handleBundleCartSubmit(e);
            }
          }, true);
        }
        
        setTimeout(overrideCartMechanisms, 500);
        setTimeout(overrideCartMechanisms, 2000);
        setInterval(overrideCartMechanisms, 5000);
      }
      
      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDynamicBundleSystem);
      } else {
        initDynamicBundleSystem();
      }
      
      // Also initialize after delay
      setTimeout(initDynamicBundleSystem, 1000);
      
      console.log('Dynamic Bundle System: Script loaded');
    })();
  </script>
{% endif %}

{% schema %}
{
  "name": "Bundle Components Dynamic",
  "settings": [],
  "presets": [
    {
      "name": "Bundle Components Dynamic"
    }
  ]
}
{% endschema %}
